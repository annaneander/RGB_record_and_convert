 /* * * rgb_i2c.h * * *
 *  Author: Anna Neander (2021).
 *  Based on example written by Axel Isaksson:
 *  https://github.com/is1200-example-projects/hello-temperature
 *
 *
 *  Sensor APDS9960 @ 0x39; Max 400 kHz
 *
 *  For copyright and licensing, see file COPYING
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */



#include <stdbool.h>
#include <stdint.h>   /* Declarations of uint_32 and the like */
#include <pic32mx.h>  /* Declarations of system-specific addresses etc */

#include "rgb_i2c.h"

#include "display.h"


uint16_t rgbc[4] = {0}; /* value of CRGB */

void rgb_i2c_init(void){

	/* -----  Set up I2C ---  code from example w/ comments--- */

	I2C1CON = 0x0;   /* turn off and reset i2c */
	/* I2C clock freq is generated by dividing the peripheral bus clock down. PBCLK is set to 40Mhz in OSCCON <20:19>. Then 0x0C2 --> 100 kHz ; 0x02C --> 400 kHz */
	I2C1BRG = 0x0C2;   /* baud rate generator clk --> 100 kHz*/
	I2C1STAT = 0x0;    /* clear acken, recieve, stop, restart, start */
//	I2C1CONSET = 1 << 13;   /* Stop in idle mode */
	I2C1CONSET = 1 << 15;   /* Turn on i2c. Sets pins to tri-state */

	/* ------- End code from example --- */

  /* Enable external interrupts to pin 2. INT1. Pin2 is input by default */
  // flagga: IFS(0) <7>
  // enable: IEC(0) <7>
  // prio: IPC1 <28:26>  ; sub: <25:24>

	/*
	 * rgb = I2C1RCV; //Clear receive buffer R ??
	 *(rgb+1) = I2C1RCV; //Clear receive buffer G  ??
	 *(rgb+2) = I2C1RCV; //Clear receive buffer B ??
	 *(rgb+3) = I2C1RCV; //Clear receive buffer L ??
	 */

	/* ----- write to control register in sensor ----- */

	/*
	   TODO:
	   WTIME register and WLONG - wait time
	   the Sleep After Interrupt bit, SAI ? set?
	 */

	write_to_reg(ATIME, 0xC0); /* Measure time: 175 ms for max (2^16 bit) color range */
  write_to_reg(A_GAIN, 0x1); /* Gain Control: 4x */

	//  write_to_reg(WTIME, 0x); /* delay; default 2.78 ms */
	//  write_to_reg(WLONG , 0x); /* <1> Wait Long Enable --> time x12 */

	//write_to_reg(A_PERS, 0x); /* persistence */

	//  write_to_reg(AILTL, 0x);  /* low threshold, lower byte  */
	//  write_to_reg(AILTH, 0x); /* low threshold, higher byte  */


//	write_to_reg(ENABLE, 0x1B); /* Wait <3>, Interrupt<4>, ALS <1>, Start <0>*/
  write_to_reg(ENABLE, 0xB); /* Wait, Start  */
}


/* check if the right sensor is connected */
bool hello_rgbc(){
  return (read_from_reg(RGBC_ID) == 0xAB);
}

/* ---------  Below functions from example  --------------
--------- (partly modified + added comments) --------------- */

/* Wait for I2C bus to become idle. When ackEN, recieve, stop, restart, start and TRSTAT (controller transmit in progress) are cleared. */
void i2c_idle() {
  //display_debug_8(&I2C1CON);
	while(I2C1CON & 0x1F || TRSSTAT);
}

/* Send one byte on I2C bus, returns inverted ack/nack status of transaction */
bool i2c_send(uint8_t data) {
	i2c_idle();
	I2CTRN = data;
	i2c_idle();
	return !(ACKSTAT);
}

/*  Receive one byte from I2C bus to reg I2CRV */
void i2c_recv() {
	i2c_idle();
	RCVENBL;
	i2c_idle();
	CL_OVERFLOW;
  //display_debug_2(&I2CRCV); //00000
}

/* Send acknowledge conditon on the bus */
void i2c_ack() {
	i2c_idle();
	ACK;
  ACKEN;
}

/* Send not-acknowledge conditon on the bus */
void i2c_nack() {
	i2c_idle();
	NACK;
	ACKEN;
}

/* Send start conditon on the bus */
void i2c_start() {
	i2c_idle();
	START;
	i2c_idle();
}

/* Send restart conditon on the bus */
void i2c_restart() {
	i2c_idle();
	RESTART;
	i2c_idle();
}

/* Send stop conditon on the bus */
void i2c_stop() {
  //Fastnar på detta. bit ACKEN är set efter en nack()
	//i2c_idle();
	STOP;
  i2c_idle();

}

/* check ACKSTAT after transmit? */
/* check busscollision BCL?  - cleared when bus disabled */
/* check write to trn-collision WRCOL?  - cleared when bus disabled */

/* ------ End copied functions from example ------------- */


/* write one byte (data) to register (reg) in sensor */
bool write_to_reg(uint8_t reg, uint8_t data){
	bool status = 0;
	do {
		i2c_start();
	} while(!i2c_send(WRITE_SENSOR));
	status = (i2c_send(reg) && i2c_send(data));
	i2c_stop();
	return status;
}
/*   I2C1ADD	 adressen kolla! */

/* read one byte from register (reg) in sensor */
uint8_t read_from_reg(uint8_t reg){
  //display_string(2, "in read from");
  //display_update();
	bool status = 0;
  i2c_start();  //TODO skriv om med intrrrupts!
  do {
    i2c_start();
  } while(!i2c_send(WRITE_SENSOR));
  status = i2c_send(reg);
	if (status){
	  i2c_restart();
    status = i2c_send(READ_SENSOR);       /* Send read */
    //display_debug_2(&I2CRCV); //00000
    //kolla status, skirv om med intrrrupts
    i2c_recv();
    i2c_nack();
    i2c_stop();
}
	return I2CRCV;
}


/* läs in värdet av RGBC och skriv ut på display */
bool get_RGBC(){
	bool status = 0;

  while (1)
  rgbc_from_reg(CLEAR_DATA_L);
  //display_rgbc();
  //rgb565_to_rgb888();
	return status;
}


/* Read CRGB values from sensor. Read 8 bytes from register (reg) in sensor to global array rgbc. */
void rgbc_from_reg(uint8_t reg){
	volatile uint8_t *data;
	bool status = 0;
	int i;
  char * value;
	do {
		i2c_start();
	} while(!i2c_send(WRITE_SENSOR));  /* Send write */
	if (!i2c_send(reg)) {
		// TODO:Hantera nack från slave
	}
	do {
		i2c_restart();
	} while(!i2c_send(READ_SENSOR)); /* Send read */

   // Alla värden på CRGB låses och hämtas om läsningen börjar med adressen för C_LOW. 4x2 byte (totalt 8 byte).
   for(i = 0; i<4; i++) {
     i2c_recv();
     *(rgbc+i) = I2CRCV <<8;
     i2c_ack();
     i2c_recv();
     *(rgbc+i) |= I2CRCV;
     if(i<3)
      i2c_ack();
   }

	i2c_nack();
	i2c_stop();

  //display_debug(&(rgbc[0]));    //R
	//display_debug_2(&I2C1RCV);    //G
  for (i = 0; i<4; i++){
    value = itoaconv(*(rgbc+i));
    display_string(i,value);
    }
    display_update();
}














/* -------------------- används inte -----------------       */

/* read one byte from register (reg) in sensor */
uint8_t* p_read_from_reg(uint8_t reg){
  uint8_t* data = 0x0;
	bool status = 0;
	do {
		i2c_start();
	} while(!i2c_send(WRITE_SENSOR));  /* Send write */
	if (!i2c_send(reg)) {
		// TODO:Hantera ev nack från slave
	}
	do {
		i2c_restart();
	} while(!i2c_send(READ_SENSOR)); /* Send read */
	i2c_recv(); //hantera ev fel!
	i2c_nack();
	i2c_stop();
  //display_debug(0xBF805060);  //I2CRCV
  //display_debug_8(&I2CRCV);  //   (I2C1RCV)
  *data = (I2CRCV);
	return data;
}
