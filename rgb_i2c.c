/*

Sensor APDS9960 @ 0x39; Max 400 kHz

Author: Anna Neander (2021)
Based on example from https://github.com/is1200-example-projects/hello-temperature written by Axel Isaksson.

For copyright and licensing, see file COPYING
*/



#include <stdbool.h>
#include <stdint.h>   /* Declarations of uint_32 and the like */
#include <pic32mx.h>  /* Declarations of system-specific addresses etc */

#include "rgb_i2c.h"

#include "display.h"


uint16_t rgb[4] = {0}; /* value of RGBC */

void rgb_i2c_init(void){

  /* -----  Set up I2C ---  code from example --- */

  	I2C1CON = 0x0; /* turn off and reset i2c before setting baud*/
    /* I2C Baud rate should be less than 400 kHz, is generated by dividing
    the 40 MHz peripheral bus clock down.
    0x0C2 --> 100 kHz ; 0x02C --> 400 kHz */
    I2C1BRG = 0x0C2; /* baud rate generator --> 100 kHz*/
  	I2C1STAT = 0x0;  /*  clears start(3) and stop (4) and ackstat  */
  	I2C1CONSET = 1 << 13; /* Stop in idle mode */
  	I2C1CONSET = 1 << 15; /* POR - turn on i2c*/

  /* ------- End code from example --- */

  /*
    *rgb = I2C1RCV; //Clear receive buffer R ??
    *(rgb+1) = I2C1RCV; //Clear receive buffer G  ??
    *(rgb+2) = I2C1RCV; //Clear receive buffer B ??
    *(rgb+3) = I2C1RCV; //Clear receive buffer L ??
  */

 /* ----- write to control register in sensor ----- */

    /*
    Each functional engine contains controls (E.g. Gain, ADC integration time, wait time, persistence, thresholds)

    WTIME register and WLONG - wait time
    the Sleep After Interrupt bit, SAI ? set?
    */



  //  write_to_reg(ATIME, 0x); /* Measure time; default 2.78 ms */
  //  write_to_reg(WTIME, 0x); /* delay; default 2.78 ms */
  //  write_to_reg(WLONG , 0x); /* <1> Wait Long Enable --> time x12 */

    //write_to_reg(A_GAIN, 0x); /* Gain Control set to?*/
    //write_to_reg(A_PERS, 0x); /* Set to a value? */

  //  write_to_reg(AILTL, 0x);  /* low threshold, lower byte  */
  //  write_to_reg(AILTH, 0x); /* low threshold, higher byte  */

  /* control bits need to be set before enable*/
  write_to_reg(ENABLE, 0x1B); /* <> Wait, Interrupt, Start */

  }


/* ------ Below copied functions from example (+ added comments)------ */

  /* Wait for I2C bus to become idle. This is the case when <4:0> are cleared: ACKEN, RCEN (recieve), PEN (stop), RSEN (restart), SEN (start).
  || TRSTAT (controller transmit in progress) is cleared. */
  void i2c_idle() {
  	while(I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
  }

  /* Send one byte on I2C bus, returns inverted ack/nack status of transaction */
  bool i2c_send(uint8_t data) {
  	i2c_idle();
  	I2C1TRN = data;
  	i2c_idle();
  	return !(I2C1STAT & (1 << 15)); /* OBS INV ACKSTAT */
  }

  /* Receive one byte from I2C bus */
  uint8_t i2c_recv() {
  	i2c_idle();
  	I2C1CONSET = 1 << 3; //RCEN = 1
  	i2c_idle();
  	I2C1STATCLR = 1 << 6; //I2COV = 0
  	return I2C1RCV;
  }

  /* Send acknowledge conditon on the bus */
  void i2c_ack() {
  	i2c_idle();
  	I2C1CONCLR = 1 << 5; //ACKDT = 0
  	I2C1CONSET = 1 << 4; //ACKEN = 1
  }

  /* Send not-acknowledge conditon on the bus */
  void i2c_nack() {
  	i2c_idle();
  	I2C1CONSET = 1 << 5; //ACKDT = 1
  	I2C1CONSET = 1 << 4; //ACKEN = 1
  }

  /* Send start conditon on the bus */
  void i2c_start() {
  	i2c_idle();
  	I2C1CONSET = 1 << 0; //SEN
  	i2c_idle();
  }

  /* Send restart conditon on the bus */
  void i2c_restart() {
  	i2c_idle();
  	I2C1CONSET = 1 << 1; //RSEN
  	i2c_idle();
  }

  /* Send stop conditon on the bus */
  void i2c_stop() {
  	i2c_idle();
  	I2C1CONSET = 1 << 2; //PEN
  	i2c_idle();
  }

/* ------ End copied functions from example ------------- */


/* write one byte (data) to register (reg) in sensor */
bool write_to_reg(uint8_t reg, uint8_t data){
  bool status = 0;
  do {
    i2c_start(); //TODO:skriv om med interrupts?
  } while(!i2c_send(WRITE_SENSOR));  /* Send write */
    status = (i2c_send(reg) && i2c_send(data));
    i2c_stop();
    return status;
  }


/* read one byte from register (reg) in sensor */
uint8_t read_from_reg(uint8_t reg){
  uint8_t data = 0x0;
  bool status = 0;
	do {
		i2c_start();
	} while(!i2c_send(WRITE_SENSOR));  /* Send write */
    if (!i2c_send(reg)){
      // TODO:Hantera nack från slave
    }
  do {
		i2c_restart();
	} while(!i2c_send(READ_SENSOR)); /* Send read */
    data = i2c_recv();
    /*
      TODO:lägg ev till läsa fler register i rad
    */
    i2c_nack();
    i2c_stop();
    return data;
}




/* testfunktion */
bool send_data(uint8_t data){
  bool status = 0;
  uint8_t id = 0x0;

  //snabbtest för kontakt:
  id = read_from_reg(DEVICE_ID);
  display_debug(&I2C1RCV); // värde: 0xAB


  /* läs värdet av RGBC*/
  //read_from_reg(CLEAR_DATA_L);



  return status;
	}


/*  funktion för att läsa flera byte */
